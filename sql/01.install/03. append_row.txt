
CREATE OR REPLACE FUNCTION public.append(
    mpoint,
    point, timestamp)
  RETURNS mpoint AS
$BODY$
DECLARE
    f_mpoint            alias for $1;
    tp                alias for $2;
 	tp2                alias for $3;
    traj_prefix            char(50);
    traj_suffix            char(50);   
    f_mpoint_segtable_name    char(200);
    table_oid            char(100);
    mpid                integer;
    segid                integer;
    mp_count            integer;
    mp_seq                record;
    max_tpseg_count    integer;
    cnt_mpid            integer;   
    sql                text;
    next_segid            integer;
    tp_seg_size            integer;
    new_segid            integer;
	jsonfiles			json;
	trajid			integer;
BEGIN
    -- traj_prefix := current_setting('traj.prefix');
    -- traj_suffix := current_setting('traj.suffix');
    
    traj_prefix := 'mpseq_' ;  
	traj_suffix := 'mpoint';
	sql := 'select f_segtableoid from mpoint_columns where type = ' || quote_literal(traj_suffix);
    RAISE DEBUG '%', sql;
	RAISE INFO '%', sql;
    EXECUTE sql INTO trajid;
	
    f_mpoint_segtable_name := traj_prefix || trajid ;
    mpid := f_mpoint.id;

    sql := 'SELECT COUNT(*) FROM ' || quote_ident(f_mpoint_segtable_name) || 
        ' WHERE mpid = ' || f_mpoint.id;
    RAISE DEBUG '%', sql;
    EXECUTE sql INTO cnt_mpid;
    
    -- tpseg_size 
    sql := 'select tpseg_size from mpoint_columns where f_mpoint_segtable_name = ' || quote_literal(f_mpoint_segtable_name);
    RAISE DEBUG '%', sql;
    EXECUTE sql INTO tp_seg_size;
		
    IF (cnt_mpid < 1) THEN
        EXECUTE 'INSERT INTO ' || quote_ident(f_mpoint_segtable_name) || '(mpid, segid, mpcount, time, tpseg) 
            VALUES($1, 1, 1, ARRAY[($3)]::timestamp without time zone[], ARRAY[($2)]::point[])'
        USING mpid, tp, tp2;
		--get json ;
		 sql := 'select row_to_json((SELECT d from (select time,tpseg ) d)) from  ' || quote_ident(f_mpoint_segtable_name) ;
   		 RAISE DEBUG '%', sql;
    	EXECUTE sql INTO jsonfiles;
		
		EXECUTE 'update ' || quote_ident(f_mpoint_segtable_name) || ' set jsonfile = ($4) WHERE mpid = $1'
       USING  mpid, tp, tp2,jsonfiles;
    END IF;
    
    IF(cnt_mpid > 0) THEN
        sql := 'select segid from ' || quote_ident(f_mpoint_segtable_name) ||
                ' where mpid = ' || f_mpoint.id || ' and next_segid IS NULL';
        RAISE DEBUG '%', sql;
        EXECUTE sql INTO segid;
        sql := 'select array_upper((select tpseg from ' || quote_ident(f_mpoint_segtable_name) || 
            ' where mpid = ' || f_mpoint.id || ' and segid = ' || segid || '), 1)';
        RAISE DEBUG '%', sql;
        EXECUTE sql INTO max_tpseg_count;
       
        IF( segid IS NOT NULL AND max_tpseg_count < tp_seg_size) THEN
            EXECUTE 'UPDATE ' || quote_ident(f_mpoint_segtable_name) || 
                ' set mpcount = mpcount+1, time = array_append(time, $2) , tpseg = array_append(tpseg, $3) 
                where mpid = $4 and segid = $5 '
            USING tp, tp2, tp, mpid, segid; 
			 sql := 'select row_to_json((SELECT d from (select time,tpseg ) d)) from  ' || quote_ident(f_mpoint_segtable_name) ;
   		    RAISE DEBUG '%', sql;
			EXECUTE sql INTO jsonfiles;
			
    	    EXECUTE 'update ' || quote_ident(f_mpoint_segtable_name) || ' set jsonfile = ($6) WHERE mpid = $4 and segid = $5'
            USING  tp, tp2, tp, mpid, segid,jsonfiles;
        ELSE 
            EXECUTE 'select MAX(segid) from ' || quote_ident(f_mpoint_segtable_name) || ' where mpid = $1'
            INTO new_segid USING mpid;

            EXECUTE 'INSERT INTO ' || quote_ident(f_mpoint_segtable_name) ||'(mpid, segid, before_segid, mpcount, time, tpseg) 
                VALUES( $1,  ' || new_segid+1 || ', $2, 1, ARRAY[( $3)]::timestamp without time zone[], ARRAY[( $4)]::point[])'
            USING f_mpoint.id, segid, tp2, tp;
			
            EXECUTE 'UPDATE ' || quote_ident(f_mpoint_segtable_name) || 
                ' set next_segid = ' || new_segid+1 || ' where mpid = $1 and segid = $2'
            USING mpid, segid;
			sql := 'select row_to_json((SELECT d from (select time,tpseg ) d)) from  ' || quote_ident(f_mpoint_segtable_name) ;
   			RAISE DEBUG '%', sql;
    		EXECUTE sql INTO jsonfiles;
			
			EXECUTE 'update ' || quote_ident(f_mpoint_segtable_name) || ' set jsonfile = ($3) WHERE mpid = $1  and segid = '|| new_segid+1 
     		USING   mpid, segid,jsonfiles;
        END IF;
    END IF;

    return f_mpoint;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;
ALTER FUNCTION public.append(mpoint, point, timestamp)
  OWNER TO postgres;




CREATE OR REPLACE FUNCTION public.append(
    mdouble,
    double precision, timestamp)
  RETURNS mdouble AS
$BODY$
DECLARE
    f_mpoint            alias for $1;
    tp                alias for $2;
 	tp2                alias for $3;
    traj_prefix            char(50);
    traj_suffix            char(50);   
    f_mpoint_segtable_name    char(200);
    table_oid            char(100);
    mpid                integer;
    segid                integer;
    mp_count            integer;
    mp_seq                record;
    max_tpseg_count    integer;
    cnt_mpid            integer;   
    sql                text;
    next_segid            integer;
    tp_seg_size            integer;
    new_segid            integer;
	trajid			integer;
	jsonfiles			json;
BEGIN
    -- traj_prefix := current_setting('traj.prefix');
    -- traj_suffix := current_setting('traj.suffix');
    
    traj_prefix := 'mdseq_' ;  
	traj_suffix := 'mdouble';
	sql := 'select f_segtableoid from mpoint_columns where f_segtableoid = ' || quote_literal(f_mpoint.id );
    RAISE DEBUG '%', sql;
	RAISE INFO '%', sql;
    EXECUTE sql INTO trajid;
	
    f_mpoint_segtable_name := traj_prefix || trajid ;
    mpid := f_mpoint.id;

    sql := 'SELECT COUNT(*) FROM ' || quote_ident(f_mpoint_segtable_name) || 
        ' WHERE mpid = ' || f_mpoint.id;
    RAISE DEBUG '%', sql;
    EXECUTE sql INTO cnt_mpid;
    
    -- tpseg_size 
    sql := 'select tpseg_size from mpoint_columns where f_mpoint_segtable_name = ' || quote_literal(f_mpoint_segtable_name);
    RAISE DEBUG '%', sql;
    EXECUTE sql INTO tp_seg_size;
		
    IF (cnt_mpid < 1) THEN
        EXECUTE 'INSERT INTO ' || quote_ident(f_mpoint_segtable_name) || '(mpid, segid, mdcount, time, tpseg) 
            VALUES($1, 1, 1, ARRAY[($3)]::timestamp without time zone[], ARRAY[($2)]::double precision[])'
        USING mpid, tp, tp2;
		sql := 'select row_to_json((SELECT d from (select time,tpseg ) d)) from  ' || quote_ident(f_mpoint_segtable_name) ;
   		RAISE DEBUG '%', sql;
    	EXECUTE sql INTO jsonfiles;
		
		EXECUTE 'update ' || quote_ident(f_mpoint_segtable_name) || ' set jsonfile = ($4) WHERE mpid = $1'
       	USING  mpid, tp, tp2,jsonfiles;
    END IF;
    
    IF(cnt_mpid > 0) THEN
        sql := 'select segid from ' || quote_ident(f_mpoint_segtable_name) ||
                ' where mpid = ' || f_mpoint.id || ' and next_segid IS NULL';
        RAISE DEBUG '%', sql;
        EXECUTE sql INTO segid;
        sql := 'select array_upper((select tpseg from ' || quote_ident(f_mpoint_segtable_name) || 
            ' where mpid = ' || f_mpoint.id || ' and segid = ' || segid || '), 1)';
        RAISE DEBUG '%', sql;
        EXECUTE sql INTO max_tpseg_count;
       
        IF( segid IS NOT NULL AND max_tpseg_count < tp_seg_size) THEN
            EXECUTE 'UPDATE ' || quote_ident(f_mpoint_segtable_name) || 
                ' set mdcount = mdcount+1, time = array_append(time, $2) , tpseg = array_append(tpseg, $3) 
                where mpid = $4 and segid = $5 '
            USING tp, tp2, tp, mpid, segid; 
			 sql := 'select row_to_json((SELECT d from (select time,tpseg ) d)) from  ' || quote_ident(f_mpoint_segtable_name) ;
   		    RAISE DEBUG '%', sql;
			EXECUTE sql INTO jsonfiles;
			
    	    EXECUTE 'update ' || quote_ident(f_mpoint_segtable_name) || ' set jsonfile = ($6) WHERE mpid = $4 and segid = $5'
            USING  tp, tp2, tp, mpid, segid,jsonfiles;
        ELSE 
            EXECUTE 'select MAX(segid) from ' || quote_ident(f_mpoint_segtable_name) || ' where mpid = $1'
            INTO new_segid USING mpid;

            EXECUTE 'INSERT INTO ' || quote_ident(f_mpoint_segtable_name) ||'(mpid, segid, before_segid, mdcount, time, tpseg) 
                VALUES( $1,  ' || new_segid+1 || ', $2, 1, ARRAY[( $3)]::timestamp without time zone[], ARRAY[( $4)]::double precision[])'
            USING f_mpoint.id, segid, tp2, tp;
			
            EXECUTE 'UPDATE ' || quote_ident(f_mpoint_segtable_name) || 
                ' set next_segid = ' || new_segid+1 || ' where mpid = $1 and segid = $2'
            USING mpid, segid;
			sql := 'select row_to_json((SELECT d from (select time,tpseg ) d)) from  ' || quote_ident(f_mpoint_segtable_name) ;
   			RAISE DEBUG '%', sql;
    		EXECUTE sql INTO jsonfiles;
			
			EXECUTE 'update ' || quote_ident(f_mpoint_segtable_name) || ' set jsonfile = ($3) WHERE mpid = $1  and segid = '|| new_segid+1 
     		USING   mpid, segid,jsonfiles;
        END IF;
    END IF;

    return f_mpoint;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE STRICT
  COST 100;
ALTER FUNCTION public.append(mdouble, double precision, timestamp)
  OWNER TO postgres;
  